<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SE204 - Data Mining - Interactive Material</title> <!-- Changed Title -->
    <style>
        /* --- Base Styles (Similar to previous) --- */
        body {
            font-family: Arial, sans-serif;
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
            color: #333;
        }

        .container {
            max-width: 950px; /* Slightly wider for tables */
            margin: 20px auto;
            padding: 30px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            color: #0056b3; /* Cairo University Blue */
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 15px;
        }

        h2 {
            margin-top: 20px;
            margin-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 10px;
        }

        h3 {
            margin-top: 25px;
            margin-bottom: 15px;
            color: #007bff; /* Lighter Blue */
        }
        /* Added h4, h5 styles for example steps */
        h4 {
            color: #17a2b8; /* Teal for steps */
            margin-top: 1.5em;
            margin-bottom: 1em;
        }
         h5 {
            color: #6c757d; /* Gray for sub-steps */
            margin-top: 1.2em;
            margin-bottom: 0.8em;
            font-style: italic;
        }


        /* --- Main Tabs Styles --- */
        .main-tabs {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-bottom: 25px;
            border-bottom: 2px solid #0056b3;
        }

        .main-tabs .tab-button {
            padding: 12px 18px;
            border: none;
            background: none;
            color: #0056b3;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            transition: background-color 0.3s ease, color 0.3s ease;
            margin-bottom: -2px;
            border-bottom: 2px solid transparent;
            text-align: center;
        }

        .main-tabs .tab-button.active {
            background: #0056b3;
            color: white;
            border-bottom: 2px solid #0056b3;
        }
        .main-tabs .tab-button:hover:not(.active) {
            background-color: #e9ecef;
            border-bottom: 2px solid #adb5bd;
        }

        /* --- Content Sections --- */
        .main-content {
            display: none;
            animation: fadeIn 0.5s;
        }
        .main-content.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- Accordion Styles (Glossary & Examples) --- */
        .accordion {
            border: 1px solid #dee2e6; border-radius: 5px; overflow: hidden; margin-bottom: 20px;
        }
        /* Nested accordion styling */
         .accordion .accordion {
            margin-top: 15px;
            margin-bottom: 15px;
            border: 1px dashed #adb5bd; /* Slightly different border for nested */
         }
        .accordion-item { border-bottom: 1px solid #dee2e6; }
        .accordion-item:last-child { border-bottom: none; }
        .accordion-header {
            background-color: #f8f9fa; cursor: pointer; padding: 12px 20px; width: 100%; border: none; text-align: left; outline: none; font-size: 1.1em; font-weight: bold; transition: background-color 0.3s ease; position: relative; color: #0056b3;
        }
        /* Style for nested accordion headers */
         .accordion .accordion .accordion-header {
            font-size: 1.0em; /* Slightly smaller */
            background-color: #e9ecef; /* Different background */
            color: #004085; /* Darker blue */
         }
        #glossary .accordion-header { color: #dc3545; } /* Glossary terms red */
        .accordion-header:hover { background-color: #e9ecef; }
        .accordion .accordion .accordion-header:hover { background-color: #d6e0ea; }

        .accordion-header::after { content: '\002B'; color: #0056b3; font-weight: bold; float: right; margin-left: 5px; transition: transform 0.2s ease-in-out; }
        .accordion-header.active::after { content: "\2212"; transform: rotate(180deg); }
        .accordion-header.active { background-color: #e7f1ff; }
        .accordion .accordion .accordion-header.active { background-color: #cce5ff; }

        .accordion-panel {
            padding: 0 20px; background-color: white; max-height: 0; overflow: hidden; transition: max-height 0.4s ease-out, padding 0.4s ease-out;
        }
         /* Adjusted padding for open panels */
        .accordion-panel.open {
             padding: 15px 20px;
             max-height: 10000px; /* Sufficiently large */
        }

        .accordion-panel > * { margin-top: 15px; margin-bottom: 15px; }
        .accordion-panel > *:first-child { margin-top: 15px; }
        .accordion-panel > *:last-child { margin-bottom: 15px; }
        .accordion-panel code { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; background-color: #e9ecef; padding: 2px 5px; border-radius: 3px; font-size: 0.95em; }
        /* --- End Accordion Styles --- */

        /* --- Table Styles --- */
        table { width: auto; border-collapse: collapse; margin: 15px auto; border: 1px solid #ccc; font-size: 0.9em; }
        th, td { border: 1px solid #ccc; padding: 8px 10px; text-align: center; vertical-align: middle; }
        th { background-color: #e9ecef; font-weight: bold; }
        /* Align text left in first column for readability in detailed tables */
        td:first-child { text-align: left; }
        th:first-child { text-align: left; }
        /* Center align header for TID */
        th.tid-header { text-align: center; }
        /* Center align data for TID */
        td.tid-cell { text-align: center; }


        td code { background-color: transparent; padding: 0; font-size: 1em; }
        .check-mark { color: green; font-weight: bold; }
        .cross-mark { color: red; font-weight: bold; }
        .support-table { width: 60%; }

        /* --- Formulas Section Specifics --- */
        #formulas ul { list-style: disc; padding-left: 30px; }
        #formulas ol { list-style: decimal; padding-left: 30px; }
        #formulas .math { font-family: 'Times New Roman', serif; font-style: italic; font-size: 1.1em;}
        /* Ensure nested accordion panels have sufficient space */
        #formulas .accordion .accordion-panel {
            background-color: #fdfdff; /* Slightly off-white for nested panels */
        }

        /* --- Quiz Styles --- */
        .question { margin-bottom: 25px; padding: 20px; border: 1px solid #dee2e6; border-radius: 8px; background-color: #ffffff; position: relative; }
        .question p { margin: 0 0 15px; font-weight: bold; font-size: 1.05em; }
        .options { display: flex; flex-direction: column; gap: 10px; }
        .option-button { padding: 10px 15px; border: 1px solid #ced4da; background: #f8f9fa; color: #495057; cursor: pointer; border-radius: 5px; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease; width: 100%; }
        .option-button:hover { background-color: #e9ecef; border-color: #adb5bd; }
        .option-button.selected { background: #007bff; color: white; border-color: #0056b3; }
        .check-answer { margin-top: 15px; padding: 10px 20px; border: none; background: #28a745; color: white; cursor: pointer; border-radius: 5px; font-weight: bold; transition: background-color 0.2s ease; }
        .check-answer:hover { background-color: #218838; }
        .feedback { margin-top: 15px; padding: 10px; border-radius: 5px; font-weight: bold; }
        .feedback.correct { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .feedback.incorrect { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        /* --- Example Box Styles (Used for transaction data display) --- */
        .example-box {
            background-color: #f8f9fa;
            border-left: 3px solid #0056b3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 0 5px 5px 0;
        }

        .example-box table {
            margin: 10px auto; /* Center tables in example boxes */
            width: auto;
        }

        .example-box ul, .example-box ol {
            margin: 10px 0;
            padding-left: 20px;
        }
         .example-box hr {
            margin: 15px 0;
            border: 0;
            border-top: 1px dashed #adb5bd;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SE204 - Lecture 2 Data Mining Concepts</h1> <!-- Updated Title -->

        <!-- Main Tab Buttons -->
        <div class="main-tabs">
            <button class="tab-button active" data-tab="glossary">Glossary</button>
            <button class="tab-button" data-tab="formulas">Concepts & Examples</button>
            <button class="tab-button" data-tab="fill">Fill in the Blank</button>
            <button class="tab-button" data-tab="tf">True/False</button>
            <button class="tab-button" data-tab="mc">Multiple Choice</button>
        </div>

        <!-- Glossary Section (Accordion) -->
        <section id="glossary" class="main-content active">
            <h2>Glossary of Terms</h2>
            <div class="glossary-accordion accordion">
                <!-- Data Mining & FPM Terms Only -->
                <div class="accordion-item"><button class="accordion-header">Apriori Algorithm</button><div class="accordion-panel"><p>A classic algorithm for frequent itemset mining and association rule learning over transactional databases. It uses the Apriori principle for candidate generation and pruning.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Apriori Principle</button><div class="accordion-panel"><p>The principle stating that if an itemset is frequent, then all of its subsets must also be frequent. Used to prune the search space in the Apriori algorithm.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Association Rule</button><div class="accordion-panel"><p>An implication expression of the form X → Y, where X (antecedent) and Y (consequent) are disjoint itemsets. It indicates that transactions containing X are likely to also contain Y.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Association Rule Mining</button><div class="accordion-panel"><p>The task of discovering interesting association rules (based on support and confidence thresholds) within large datasets.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Classification (Data Mining)</button><div class="accordion-panel"><p>A predictive data mining task where the goal is to assign input data to specific, predefined categories or classes using a model trained on labeled data.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Closed Frequent Itemset</button><div class="accordion-panel"><p>A frequent itemset for which none of its proper supersets have the exact same support count.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Clustering (Data Mining)</button><div class="accordion-panel"><p>A descriptive data mining task that involves grouping similar objects or data points together based on their characteristics, without using predefined labels.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Complex Data</button><div class="accordion-panel"><p>Non-traditional data types beyond simple numeric or categorical values, such as text, hyperlinks, images, audio, video, sequences (DNA), and spatio-temporal data (climate).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Conditional FP-Tree</button><div class="accordion-panel"><p>A sub-tree constructed from a conditional pattern base during the FP-Growth algorithm, used to mine frequent itemsets related to a specific item.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Conditional Pattern Base</button><div class="accordion-panel"><p>In FP-Growth, the set of prefix paths in the FP-Tree co-occurring with a specific suffix pattern (item).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Confidence (Association Rule)</button><div class="accordion-panel"><p>A measure of the reliability of an association rule X → Y. It's the conditional probability P(Y|X), calculated as support(X∪Y) / support(X).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Data Cleaning</button><div class="accordion-panel"><p>The process of handling noise, incomplete values, and inconsistencies in data before analysis or mining.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Data Integration</button><div class="accordion-panel"><p>Combining data from multiple heterogeneous or homogeneous sources into a unified view, often involving resolving schema and data conflicts.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Data Mining</button><div class="accordion-panel"><p>The process of discovering hidden, interesting, and useful patterns, correlations, trends, and knowledge from large amounts of data.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Data Mining Models</button><div class="accordion-panel"><p>Frameworks or techniques used in data mining, broadly categorized as Predictive (predicting future values, e.g., classification, regression) and Descriptive (finding patterns describing the data, e.g., clustering, association).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Data Selection</button><div class="accordion-panel"><p>Retrieving data relevant to the specific analysis task from a larger database or data source.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Data Transformation</button><div class="accordion-panel"><p>Converting data into forms appropriate for mining, often involving summary, aggregation, normalization, or discretization operations.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Dependent Variable (Target Variable)</button><div class="accordion-panel"><p>In predictive modeling (like classification or regression), the attribute whose value is being predicted.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Descriptive Model (Data Mining)</button><div class="accordion-panel"><p>A data mining model whose objective is to find human-interpretable patterns (like correlations, trends, clusters, association rules) that describe the existing data.</p></div></div>
                 <div class="accordion-item"><button class="accordion-header">Disjoint Itemsets</button><div class="accordion-panel"><p>Two itemsets that have no items in common (their intersection is empty).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Distributed Data Mining</button><div class="accordion-panel"><p>Data mining techniques designed for data that is geographically distributed or stored across multiple locations/entities.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">FP-Growth Algorithm</button><div class="accordion-panel"><p>An efficient algorithm for mining frequent itemsets that avoids explicit candidate generation by using a compact tree structure (FP-Tree).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">FP-Tree (Frequent Pattern Tree)</button><div class="accordion-panel"><p>A compact prefix tree structure used in the FP-Growth algorithm to store frequent item information from a transactional database.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Frequent Itemset</button><div class="accordion-panel"><p>An itemset whose support (frequency of occurrence) in the dataset is greater than or equal to a user-defined minimum support threshold (minsup).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Frequent Pattern</button><div class="accordion-panel"><p>A general term for patterns (like itemsets, sequences, or structures) that occur frequently in data.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Frequent Pattern Mining</button><div class="accordion-panel"><p>The data mining task focused on extracting frequent patterns (often itemsets) from a dataset.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Heterogeneous Data</button><div class="accordion-panel"><p>Datasets containing attributes of different types (e.g., a mix of numerical, categorical, text).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">High Dimensionality</button><div class="accordion-panel"><p>A characteristic of datasets having a very large number of attributes or features (hundreds or thousands), posing challenges for traditional analysis techniques.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">IDLE (Python)</button><div class="accordion-panel"><p>Python's Integrated Development and Learning Environment; a simple editor and shell for writing and running Python code.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Incomplete Data</button><div class="accordion-panel"><p>Data where some attribute values are missing.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Inconsistent Data</button><div class="accordion-panel"><p>Data lacking uniformity in format or content, containing discrepancies (e.g., different date formats, inconsistent capitalization).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Independent Variables (Features)</button><div class="accordion-panel"><p>In predictive modeling, the attributes used to make a prediction about the target variable.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Itemset</button><div class="accordion-panel"><p>A collection of one or more items (e.g., {Milk, Bread}).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">K-Itemset</button><div class="accordion-panel"><p>An itemset that contains exactly k items.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Knowledge Presentation</button><div class="accordion-panel"><p>The final step in data mining where the discovered patterns and knowledge are presented to the user, often using visualization techniques.</p></div></div>
                 <div class="accordion-item"><button class="accordion-header">Market Basket Analysis</button><div class="accordion-panel"><p>A common application of association rule mining, used to identify relationships between items frequently purchased together in retail transactions.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Maximal Frequent Itemset (Max Pattern)</button><div class="accordion-panel"><p>A frequent itemset for which none of its proper supersets are also frequent.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Minimum Support Threshold (minsup)</button><div class="accordion-panel"><p>A user-defined threshold used in frequent pattern mining. An itemset is considered frequent only if its support meets or exceeds this threshold.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Mlxtend</button><div class="accordion-panel"><p>A Python library providing useful tools for data science tasks, including implementations of Apriori and FP-Growth algorithms.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Noisy Data</button><div class="accordion-panel"><p>Data containing errors or outliers (extreme values) that can distort analysis results.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Pandas (Python Library)</button><div class="accordion-panel"><p>A fundamental Python library for data manipulation and analysis, providing data structures like DataFrames.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Pattern Evaluation</button><div class="accordion-panel"><p>The step in data mining where discovered patterns are assessed based on interestingness measures to identify truly significant knowledge.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Pip (Python)</button><div class="accordion-panel"><p>The standard package installer for Python, used to install and manage third-party libraries.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Predictive Model (Data Mining)</button><div class="accordion-panel"><p>A data mining model whose objective is to predict the value of a particular target attribute based on the values of other input attributes (e.g., classification, regression).</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Python</button><div class="accordion-panel"><p>A popular, high-level, multidisciplinary programming language widely used in data science, data mining, web development, and more, known for its readability and extensive libraries.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Regression (Data Mining)</button><div class="accordion-panel"><p>A predictive data mining task where the goal is to predict a continuous numerical value.</p></div></div>
                 <div class="accordion-item"><button class="accordion-header">Scalability</button><div class="accordion-panel"><p>The ability of an algorithm or system to handle increasingly large amounts of data or computational load efficiently.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Support (Association Rule)</button><div class="accordion-panel"><p>The fraction of transactions in the dataset that contain both the antecedent (X) and the consequent (Y) of the rule X → Y. Calculated as support_count(X∪Y) / total_transactions.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Support (Itemset)</button><div class="accordion-panel"><p>The frequency or proportion of transactions in a dataset that contain a particular itemset. Calculated as support_count(Itemset) / total_transactions.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Support Count (σ)</button><div class="accordion-panel"><p>The absolute number of transactions in a dataset that contain a particular itemset.</p></div></div>
                <div class="accordion-item"><button class="accordion-header">Superset</button><div class="accordion-panel"><p>A set that contains all the elements of another set, possibly along with additional elements. If itemset X contains all items in itemset Y, X is a superset of Y.</p></div></div>
            </div> <!-- End glossary-accordion -->
        </section>

        <!-- Formulas/Concepts & Examples Section -->
        <section id="formulas" class="main-content">
             <h2>Concepts & Examples</h2>
             <!-- Data Mining Concepts Only -->
             <div class="accordion">
                 <div class="accordion-item">
                     <button class="accordion-header">Basic Frequent Pattern Mining Concepts</button>
                     <div class="accordion-panel">
                         <h4>Itemset</h4><p>A collection of one or more items. Example: <code>{Milk, Bread, Diaper}</code></p>
                         <h4>k-Itemset</h4><p>An itemset containing exactly k items. Example: <code>{Milk, Bread, Diaper}</code> is a 3-itemset.</p>
                         <h4>Support Count (σ)</h4><p>The absolute frequency of occurrence of an itemset. Formula: <code>σ(Itemset) = Count(Transactions containing Itemset)</code></p>
                         <h4>Support (s)</h4><p>The fraction/percentage of transactions containing an itemset. Formula: <code class="math">s(Itemset) = σ(Itemset) / Total Transactions (T)</code></p>
                         <div class="accordion"><div class="accordion-item"><button class="accordion-header">Example: Support Calculation</button><div class="accordion-panel">
                             <p>Transactions:</p><table><thead><tr><th class="tid-header">TID</th><th>Items</th></tr></thead><tbody><tr><td class="tid-cell">1</td><td>Bread, Milk</td></tr><tr><td class="tid-cell">2</td><td>Bread, Diaper, Beer, Eggs</td></tr><tr><td class="tid-cell">3</td><td>Milk, Diaper, Beer, Coke</td></tr><tr><td class="tid-cell">4</td><td>Bread, Milk, Diaper, Beer</td></tr><tr><td class="tid-cell">5</td><td>Bread, Milk, Diaper, Coke</td></tr></tbody></table>
                             <p>Support Count & Support for <code>{Milk, Bread, Diaper}</code>:</p><p>Occurs in TIDs 4, 5.</p><p><code>σ({Milk, Bread, Diaper}) = 2</code></p><p><code>T = 5</code></p><p><code>s({Milk, Bread, Diaper}) = 2 / 5 = 40%</code></p>
                         </div></div></div>

                         <h4>Superset</h4>
                         <p>A superset is a set that contains all elements of another set, along with possibly more elements. If an itemset X contains all elements of itemset Y, then X is a superset of Y.</p>
                         <div class="example-box">
                             <p><strong>Example 1:</strong></p>
                             <p>Given the set {A, B, C, D}, what are the supersets of {C}?</p>
                             <p>Supersets of {C} are:</p>
                             <ul>
                                 <li>{C, A}</li>
                                 <li>{C, B}</li>
                                 <li>{C, D}</li>
                                 <li>{C, A, B}</li>
                                 <li>{C, A, D}</li>
                                 <li>{C, B, D}</li>
                                 <li>{C, A, B, D}</li>
                             </ul>
                             <hr>
                              <p><strong>Example 2:</strong></p>
                             <p>Given the set {A, B, C, D}, what are the supersets of {A, B}?</p>
                              <p>Supersets of {A, B} are:</p>
                             <ul>
                                 <li>{A, B, C}</li>
                                 <li>{A, B, D}</li>
                                 <li>{A, B, C, D}</li>
                             </ul>
                         </div>


                     </div>
                 </div>
                 <div class="accordion-item">
                     <button class="accordion-header">Frequent Itemset & Minsup</button>
                     <div class="accordion-panel">
                         <p>An itemset is <strong>Frequent</strong> if its support (s) ≥ <strong>Minimum Support Threshold (minsup)</strong>.</p>
                         <div class="accordion"><div class="accordion-item"><button class="accordion-header">Example: Finding Frequent Itemsets (minsup = 60%)</button><div class="accordion-panel">
                            <p>Transactions:</p><table><thead><tr><th class="tid-header">TID</th><th>Items</th></tr></thead><tbody><tr><td class="tid-cell">1</td><td>Bread, Milk</td></tr><tr><td class="tid-cell">2</td><td>Bread, Diaper, Beer, Eggs</td></tr><tr><td class="tid-cell">3</td><td>Milk, Diaper, Beer, Coke</td></tr><tr><td class="tid-cell">4</td><td>Bread, Milk, Diaper, Beer</td></tr><tr><td class="tid-cell">5</td><td>Bread, Milk, Diaper, Coke</td></tr></tbody></table>

                            <p>Using same 5 transactions, <code>minsup = 60% (0.6)</code>. Check: <code>{Bread}, {Eggs}, {Bread, Diaper}, {Bread, Milk}, {Bread, Milk, Diaper}</code>.</p>
                             <table><thead><tr><th>Itemset</th><th>Support (s)</th><th>Frequent? (s ≥ 60%)</th></tr></thead><tbody><tr><td>{Bread}</td><td>80%</td><td class="check-mark">Yes</td></tr><tr><td>{Eggs}</td><td>20%</td><td class="cross-mark">No</td></tr><tr><td>{Bread, Diaper}</td><td>60%</td><td class="check-mark">Yes</td></tr><tr><td>{Bread, Milk}</td><td>60%</td><td class="check-mark">Yes</td></tr><tr><td>{Bread, Milk, Diaper}</td><td>40%</td><td class="cross-mark">No</td></tr></tbody></table>
                             <p>Frequent Itemsets: {Bread}, {Bread, Diaper}, {Bread, Milk}.</p>
                         </div></div></div>
                     </div>
                 </div>
                 <div class="accordion-item">
                     <button class="accordion-header">Closed and Maximal Frequent Itemsets</button>
                     <div class="accordion-panel">
                             <h4>Closed Frequent Itemset</h4>

                             <p>A frequent itemset is <strong>closed</strong> if all of its proper supersets have a support count that is <strong>different</strong> from the support count of the itemset itself.
                                <br>
                                This means its support value is not 'repeated' by any larger itemset containing it.</p>
                              <p>In simple terms:</p>
                              <ul>
                                  <li><strong>Not Closed</strong>: You can add items to the frequent itemset, and the new, larger itemset has the <strong>exact same support</strong>.
                                    <br>
                                    (Support is "repeated" by a superset).</li>
                                  <li><strong>Closed</strong>: For every way you add items to the frequent itemset to make a larger itemset, the support of that larger itemset is <strong>different</strong> from the original. (Support is "not repeated" by any superset).</li>
                              </ul>
                             <div class="accordion">
                                 <div class="accordion-item">
                                     <button class="accordion-header">Example: Is {Milk} Closed? (Using Milk/Bread Data)</button>
                                     <div class="accordion-panel">
                                         <div class="example-box">
                                             <p><strong>Transaction Data (T=4):</strong></p>
                                             <table>
                                                 <thead><tr><th class="tid-header">Transaction ID</th><th>Milk</th><th>Bread</th><th>Butter</th><th>Cheese</th></tr></thead>
                                                 <tbody>
                                                     <tr><td class="tid-cell">1</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td></tr>
                                                     <tr><td class="tid-cell">2</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="check-mark">✓</td></tr>
                                                     <tr><td class="tid-cell">3</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td></tr>
                                                     <tr><td class="tid-cell">4</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td></tr>
                                                 </tbody>
                                             </table>
                                             <hr>
                                             <p><strong>Itemset:</strong> {Milk}</p>
                                             <p><strong>Support:</strong> {Milk} appears in T1, T2, T3. Support = 3/4 = 75%.</p>
                                             <p><strong>Supersets and their Supports:</strong></p>
                                             <ul>
                                                 <li>{Milk, Bread}: Appears in T1, T2, T3. Support = 3/4 = 75%.</li>
                                                 <li>{Milk, Butter}: Appears in T1, T3. Support = 2/4 = 50%.</li>
                                                 <li>{Milk, Cheese}: Appears in T2. Support = 1/4 = 25%.</li>
                                                 <li>{Milk, Bread, Butter}: Appears in T1, T3. Support = 2/4 = 50%.</li>
                                                 <li>{Milk, Bread, Cheese}: Appears in T2. Support = 1/4 = 25%.</li>
                                                  <li>{Milk, Butter, Cheese}: Appears in NONE. Support = 0/4 = 0%.</li>
                                                 <li>{Milk, Bread, Butter, Cheese}: Appears in NONE. Support = 0/4 = 0%.</li>
                                             </ul>
                                              <hr>
                                             <p><strong>Conclusion:</strong> {Milk} is <strong>NOT closed</strong> because its superset {Milk, Bread} has the exact same support (75%).</p>
                                              <p>This happens because every transaction containing Milk also contains Bread in this dataset.</p>
                                         </div>
                                     </div>
                                 </div>
                                  <div class="accordion-item">
                                     <button class="accordion-header">Example: Is {Jeans, Belt} Closed? (Using Jeans/Belt Data)</button>
                                     <div class="accordion-panel">
                                         <div class="example-box">
                                              <p><strong>Transaction Data (T=6):</strong></p>
                                              <table>
                                                <thead><tr><th class="tid-header">TID</th><th>Shirt</th><th>Jeans</th><th>Belt</th><th>Dress</th><th>Socks</th></tr></thead>
                                                <tbody>
                                                <tr><td class="tid-cell">T1</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="cross-mark">✗</td></tr>
                                                <tr><td class="tid-cell">T2</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="check-mark">✓</td></tr>
                                                <tr><td class="tid-cell">T3</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="cross-mark">✗</td></tr>
                                                <tr><td class="tid-cell">T4</td><td class="cross-mark">✗</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td></tr>
                                                <tr><td class="tid-cell">T5</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td></tr>
                                                <tr><td class="tid-cell">T6</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="check-mark">✓</td></tr>
                                                </tbody>
                                              </table>
                                             <hr>
                                             <p><strong>Itemset:</strong> {Jeans, Belt}</p>
                                             <p><strong>Support:</strong> {Jeans, Belt} appears in T2, T3, T5, T6. Support = 4/6 ≈ 66.67%.</p>
                                              <hr>
                                             <p><strong>Step 1:</strong> Find all supersets of {Jeans, Belt}.</p>
                                             <p>Supersets include: {Jeans, Belt, Shirt}, {Jeans, Belt, Dress}, {Jeans, Belt, Socks}, etc.</p>
                                             <p><strong>Step 2:</strong> Compute the support of each superset.</p>
                                              <ul>
                                                  <li>Support({Jeans, Belt, Shirt}): Appears in T3, T5. Support = 2/6 ≈ 33.33%.</li>
                                                  <li>Support({Jeans, Belt, Dress}): Appears in T5. Support = 1/6 ≈ 16.67%.</li>
                                                  <li>Support({Jeans, Belt, Socks}): Appears in T2, T5, T6. Support = 3/6 = 50%.</li>
                                             </ul>
                                              <p><strong>Step 3:</strong> Check if any superset has the same support as {Jeans, Belt} (66.67%).</p>
                                              <p>None of the calculated superset supports (33.33%, 16.67%, 50%) are equal to 66.67%.</p>
                                              <hr>
                                             <p><strong>Conclusion:</strong> {Jeans, Belt} IS <strong>closed</strong> because none of its proper supersets have the exact same support.</p>
                                         </div>
                                     </div>
                                 </div>
                             </div>


                             <h4>Maximal Frequent Itemset (Max Pattern)</h4>
                             <p>A frequent itemset I is <strong>maximal frequent</strong> if there is no proper superset I' of I that is also frequent (i.e., meets the minimum support threshold).</p>
                             <p><strong>To check if a frequent itemset is Maximal Frequent:</strong></p>
                             <ol>
                                 <li>Find all proper supersets of the frequent itemset.</li>
                                 <li>Compute the support of each superset.</li>
                                 <li>Check the support of each superset against the minimum support threshold (minsup):
                                     <ul>
                                         <li>If *any* proper superset has support ≥ minsup (i.e., is also frequent), the original itemset is **NOT maximal**.</li>
                                         <li>If *all* proper supersets have support < minsup (i.e., are not frequent), the original itemset **IS maximal**.</li>
                                     </ul>
                                 </li>
                             </ol>
                             <div class="accordion">
                                <div class="accordion-item"><button class="accordion-header">Example: Is {Milk, Bread} Maximal? (Using Milk/Bread Data)</button><div class="accordion-panel">
                                   <div class="example-box">
                                        <p><strong>Transaction Data (T=4):</strong> (Same as above)</p>
                                         <table>
                                             <thead><tr><th class="tid-header">Transaction ID</th><th>Milk</th><th>Bread</th><th>Butter</th><th>Cheese</th></tr></thead>
                                             <tbody>
                                                 <tr><td class="tid-cell">1</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td></tr>
                                                 <tr><td class="tid-cell">2</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="check-mark">✓</td></tr>
                                                 <tr><td class="tid-cell">3</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td></tr>
                                                 <tr><td class="tid-cell">4</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td></tr>
                                             </tbody>
                                         </table>
                                       <hr>
                                        <p><strong>Let's check {Milk, Bread} (Support = 75%). Assume it is frequent.</strong></p>

                                        <p><strong>Step 1:</strong> Find proper supersets of {Milk, Bread}.</p>
                                        <p>Supersets include: {Milk, Bread, Butter}, {Milk, Bread, Cheese}, {Milk, Bread, Butter, Cheese}, etc.</p>

                                        <p><strong>Step 2:</strong> Compute support for these supersets:</p>
                                        <ul>
                                             <li>Support({Milk, Bread, Butter}): Appears in T1, T3. Support = 2/4 = 50%.</li>
                                             <li>Support({Milk, Bread, Cheese}): Appears in T2. Support = 1/4 = 25%.</li>
                                             <li>Support({Milk, Bread, Butter, Cheese}): Appears in NONE. Support = 0/4 = 0%.</li>
                                        </ul>

                                        <p><strong>Now let's consider two different minsup values:</strong></p>

                                        <hr>
                                        <p><strong>Case 1: Minsup = 50% (Support Count ≥ 2)</strong></p>
                                        <p><strong>Step 3:</strong> Check superset support against Minsup=50%.</p>
                                        <ul>
                                             <li>{Milk, Bread, Butter} (Sup=50%): Is 50% ≥ 50%? Yes. **Frequent.**</li>
                                             <li>{Milk, Bread, Cheese} (Sup=25%): Is 25% ≥ 50%? No. Not frequent.</li>
                                             <li>{Milk, Bread, Butter, Cheese} (Sup=0%): Is 0% ≥ 50%? No. Not frequent.</li>
                                        </ul>
                                        <p>Since its proper superset {Milk, Bread, Butter} is **also frequent** at Minsup=50%, {Milk, Bread} is **NOT maximal frequent** at Minsup=50%.</p>
                                        <hr>
                                        <p><strong>Case 2: Minsup = 60% (Support Count ≥ 3)</strong></p>
                                         <p><strong>Step 3:</strong> Check superset support against Minsup=60%.</p>
                                        <ul>
                                             <li>{Milk, Bread, Butter} (Sup=50%): Is 50% ≥ 60%? No. Not frequent.</li>
                                             <li>{Milk, Bread, Cheese} (Sup=25%): Is 25% ≥ 60%? No. Not frequent.</li>
                                             <li>{Milk, Bread, Butter, Cheese} (Sup=0%): Is 0% ≥ 60%? No. Not frequent.</li>
                                        </ul>
                                        <p>Since **ALL** its proper supersets are **NOT frequent** at Minsup=60%, {Milk, Bread} IS **maximal frequent** at Minsup=60%.</p>
                                   </div>
                               </div></div>
                                <div class="accordion-item"><button class="accordion-header">Example: Is {Jeans, Belt} Maximal? (Using Jeans/Belt Data, Minsup=66.67%)</button><div class="accordion-panel">
                                   <div class="example-box">
                                       <p><strong>Transaction Data (T=6):</strong> (Same as above)</p>
                                         <table>
                                                <thead><tr><th class="tid-header">TID</th><th>Shirt</th><th>Jeans</th><th>Belt</th><th>Dress</th><th>Socks</th></tr></thead>
                                                <tbody>
                                                <tr><td class="tid-cell">T1</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="cross-mark">✗</td></tr>
                                                <tr><td class="tid-cell">T2</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="check-mark">✓</td></tr>
                                                <tr><td class="tid-cell">T3</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="cross-mark">✗</td></tr>
                                                <tr><td class="tid-cell">T4</td><td class="cross-mark">✗</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td></tr>
                                                <tr><td class="tid-cell">T5</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="check-mark">✓</td></tr>
                                                <tr><td class="tid-cell">T6</td><td class="cross-mark">✗</td><td class="check-mark">✓</td><td class="check-mark">✓</td><td class="cross-mark">✗</td><td class="check-mark">✓</td></tr>
                                                </tbody>
                                              </table>
                                        <hr>
                                        <p><strong>Minsup = 66.67% (Support Count ≥ 4)</strong></p>
                                        <p><strong>Let's check {Jeans, Belt} (Support = 66.67%). It is frequent.</strong></p>

                                        <p><strong>Step 1:</strong> Find proper supersets of {Jeans, Belt}.</p>
                                        <p>Supersets include: {Jeans, Belt, Shirt}, {Jeans, Belt, Dress}, {Jeans, Belt, Socks}, {Jeans, Belt, Shirt, Dress}, etc.</p>

                                        <p><strong>Step 2:</strong> Compute support for some supersets:</p>
                                        <ul>
                                           <li>Support({Jeans, Belt, Shirt}): 2/6 ≈ 33.33%.</li>
                                           <li>Support({Jeans, Belt, Dress}): 1/6 ≈ 16.67%.</li>
                                           <li>Support({Jeans, Belt, Socks}): 3/6 = 50%.</li>
                                           <li>Support({Jeans, Belt, Shirt, Dress}): 1/6 ≈ 16.67%.</li>
                                           <li>...(Any larger supersets will have support ≤ 50%)</li>
                                        </ul>

                                        <p><strong>Step 3:</strong> Check superset support against Minsup=66.67%.</p>
                                        <ul>
                                            <li>{Jeans, Belt, Shirt} (Sup=33.33%): Is 33.33% ≥ 66.67%? No. Not frequent.</li>
                                            <li>{Jeans, Belt, Dress} (Sup=16.67%): Is 16.67% ≥ 66.67%? No. Not frequent.</li>
                                            <li>{Jeans, Belt, Socks} (Sup=50%): Is 50% ≥ 66.67%? No. Not frequent.</li>
                                            <li>... All other supersets will also be not frequent.</li>
                                        </ul>
                                        <p>Since **ALL** its proper supersets are **NOT frequent** at Minsup=66.67%, {Jeans, Belt} IS **maximal frequent**.</p>
                                   </div>
                                </div></div>
                             </div>
                         </div>
                 </div>
                 <div class="accordion-item">
                     <button class="accordion-header">Association Rules</button>
                     <div class="accordion-panel">
                         <p>Rule: <code>X → Y</code> (X, Y disjoint itemsets).</p>
                         <h4>Support (s) of Rule</h4><p><code class="math">s(X → Y) = σ(X ∪ Y) / T</code></p>
                         <h4>Confidence (c) of Rule</h4><p><code class="math">c(X → Y) = σ(X ∪ Y) / σ(X)</code></p>
                         <div class="accordion"><div class="accordion-item"><button class="accordion-header">Example: Rule Calculation</button><div class="accordion-panel">
                             <p>Using 5-transaction table:</p><table><thead><tr><th class="tid-header">TID</th><th>Items</th></tr></thead><tbody><tr><td class="tid-cell">1</td><td>Bread, Milk</td></tr><tr><td class="tid-cell">2</td><td>Bread, Diaper, Beer, Eggs</td></tr><tr><td class="tid-cell">3</td><td>Milk, Diaper, Beer, Coke</td></tr><tr><td class="tid-cell">4</td><td>Bread, Milk, Diaper, Beer</td></tr><tr><td class="tid-cell">5</td><td>Bread, Milk, Diaper, Coke</td></tr></tbody></table><p>T = 5.</p><hr/>
                             <p><strong>Rule: {Bread} → {Milk}</strong></p><p>σ(Bread∪Milk)=3. σ(Bread)=4.</p><p>Support(Rule) = 3/5=60%. Confidence(Rule) = 3/4=75%.</p><hr/>
                             <p><strong>Rule: {Milk, Diaper} → {Beer}</strong></p><p>σ(Milk∪Diaper∪Beer)=2. σ(Milk, Diaper)=3.</p><p>Support(Rule) = 2/5=40%. Confidence(Rule) = 2/3≈66.7%.</p>
                         </div></div></div>
                     </div>
                 </div>
                 <div class="accordion-item">
                      <button class="accordion-header">Apriori Algorithm</button>
                      <div class="accordion-panel">
                         <p>Level-wise frequent itemset mining using the Apriori Principle.</p>
                         <h4>Steps Overview:</h4><ol><li>Find frequent 1-itemsets (F1).</li><li>Generate candidate (k+1)-itemsets (Ck+1) from Fk.</li><li>Prune Ck+1 using Apriori Principle.</li><li>Scan DB to find frequent (k+1)-itemsets (Fk+1) from Ck+1.</li><li>Repeat until no more frequent itemsets found.</li></ol>
                         <h4>Rule Generation:</h4><p>From frequent itemsets L, generate rules S → (L-S) and check minimum confidence.</p>
                         <h4>Drawbacks:</h4><p>Multiple DB scans, large candidate sets.</p>

                         <!-- Original Simple Example -->
                         <div class="accordion"><div class="accordion-item"><button class="accordion-header">Simple Apriori Walkthrough (minsup=50% / σ≥3)</button><div class="accordion-panel">
                             <p>Transactions:</p><table><thead><tr><th class="tid-header">TID</th><th>Items</th></tr></thead><tbody><tr><td class="tid-cell">1</td><td>M, B, T</td></tr><tr><td class="tid-cell">2</td><td>M, B</td></tr><tr><td class="tid-cell">3</td><td>B, T</td></tr><tr><td class="tid-cell">4</td><td>M, B, T, E</td></tr><tr><td class="tid-cell">5</td><td>B, T</td></tr></tbody></table><p>Minsup count ≥ 3.</p>
                             <p><strong>F1 = {{M}:3, {B}:5, {T}:4}</strong> ({E}:1 is infrequent)</p>
                             <p><strong>C2 = {{M,B}, {M,T}, {B,T}}</strong></p>
                             <p><strong>F2 = {{M,B}:3, {B,T}:4}</strong> ({M,T}:2 is infrequent)</p>
                             <p><strong>C3 = {{M,B,T}}</strong>. Subset {M,T} not in F2. Prune.</p>
                             <p><strong>C3 = {}</strong>. Stop.</p>
                             <p><strong>Frequent Itemsets = {{M}, {B}, {T}, {M,B}, {B,T}}</strong></p>
                             <p><strong>Rules (minconf=80%):</strong> {M}→{B}(c=3/3=100% ✓), {B}→{M}(c=3/5=60% ✗), {B}→{T}(c=4/5=80% ✓), {T}→{B}(c=4/4=100% ✓)</p>
                             <p><strong>Final Rules: {M}→{B}, {B}→{T}, {T}→{B}</strong></p>
                         </div></div></div>

                         <!-- **** NEW: DETAILED APRIORI EXAMPLE FROM IMAGES **** -->
                         <div class="accordion">
                           <div class="accordion-item">
                               <button class="accordion-header">Detailed Apriori Walkthrough (Minsup=40%, Minconf=60%)</button>
                               <div class="accordion-panel">
                                   <h4>Problem Parameters</h4>
                                   <ul>
                                       <li>Minimum Support = 40% (Requires support count ≥ 0.40 * 5 = 2)</li>
                                   </ul>

                                   <h4>Step 1: Transaction Dataset</h4>
                                   <p>Total transactions (T): 5</p>
                                   <table>
                                       <thead><tr><th class="tid-header">TID</th><th>Set of items</th></tr></thead>
                                       <tbody>
                                           <tr><td class="tid-cell">1</td><td>Bread, Butter, Milk</td></tr>
                                           <tr><td class="tid-cell">2</td><td>Eggs, Milk, Yogurt</td></tr>
                                           <tr><td class="tid-cell">3</td><td>Bread, Cheese, Eggs, Milk</td></tr>
                                           <tr><td class="tid-cell">4</td><td>Eggs, Milk, Yogurt</td></tr>
                                           <tr><td class="tid-cell">5</td><td>Cheese, Milk, Yogurt</td></tr>
                                       </tbody>
                                   </table>

                                   <h4>Step 2: Individual Item Frequency (C1 → L1)</h4>
                                   <table>
                                       <thead><tr><th>Item</th><th>Transactions</th><th>Count (σ)</th><th>Support (s)</th><th>Meet Threshold? (≥ 40%)</th></tr></thead>
                                       <tbody>
                                           <tr><td>Bread</td><td>1, 3</td><td>2</td><td>2/5 = 40%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>Butter</td><td>1</td><td>1</td><td>1/5 = 20%</td><td class="cross-mark">No</td></tr>
                                           <tr><td>Cheese</td><td>3, 5</td><td>2</td><td>2/5 = 40%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>Eggs</td><td>2, 3, 4</td><td>3</td><td>3/5 = 60%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>Milk</td><td>1, 2, 3, 4, 5</td><td>5</td><td>5/5 = 100%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>Yogurt</td><td>2, 4, 5</td><td>3</td><td>3/5 = 60%</td><td class="check-mark">Yes</td></tr>
                                       </tbody>
                                   </table>
                                   <p><strong>L1 (Frequent 1-Itemsets):</strong> {Bread}, {Cheese}, {Eggs}, {Milk}, {Yogurt}</p>

                                   <h4>Step 3: Generate 2-Itemsets (C2 → L2)</h4>
                                   <p>(Generate candidates C2 by joining L1 items)</p>
                                   <table>
                                       <thead><tr><th>2-Itemset</th><th>Transactions</th><th>Count (σ)</th><th>Support (s)</th><th>Meet Threshold? (≥ 40%)</th></tr></thead>
                                       <tbody>
                                           <tr><td>{Bread, Cheese}</td><td>3</td><td>1</td><td>1/5 = 20%</td><td class="cross-mark">No</td></tr>
                                           <tr><td>{Bread, Eggs}</td><td>3</td><td>1</td><td>1/5 = 20%</td><td class="cross-mark">No</td></tr>
                                           <tr><td>{Bread, Milk}</td><td>1, 3</td><td>2</td><td>2/5 = 40%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>{Bread, Yogurt}</td><td>-</td><td>0</td><td>0/5 = 0%</td><td class="cross-mark">No</td></tr>
                                           <tr><td>{Cheese, Eggs}</td><td>3</td><td>1</td><td>1/5 = 20%</td><td class="cross-mark">No</td></tr>
                                           <tr><td>{Cheese, Milk}</td><td>3, 5</td><td>2</td><td>2/5 = 40%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>{Cheese, Yogurt}</td><td>5</td><td>1</td><td>1/5 = 20%</td><td class="cross-mark">No</td></tr>
                                           <tr><td>{Eggs, Milk}</td><td>2, 3, 4</td><td>3</td><td>3/5 = 60%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>{Eggs, Yogurt}</td><td>2, 4</td><td>2</td><td>2/5 = 40%</td><td class="check-mark">Yes</td></tr>
                                           <tr><td>{Milk, Yogurt}</td><td>2, 4, 5</td><td>3</td><td>3/5 = 60%</td><td class="check-mark">Yes</td></tr>
                                       </tbody>
                                   </table>
                                   <p><strong>L2 (Frequent 2-Itemsets):</strong> {Bread, Milk}, {Cheese, Milk}, {Eggs, Milk}, {Eggs, Yogurt}, {Milk, Yogurt}</p>

                                   <h4>Step 4: Generate 3-Itemsets (C3 → L3)</h4>
                                    <p>(Generate candidates C3 by joining L2 itemsets sharing first item - e.g., {Eggs, Milk} and {Eggs, Yogurt} -> {Eggs, Milk, Yogurt})</p>
                                    <p>Candidate C3: {Eggs, Milk, Yogurt}.</p>
                                    <p>Check subsets: {Eggs, Milk} (in L2 ✓), {Eggs, Yogurt} (in L2 ✓), {Milk, Yogurt} (in L2 ✓). No pruning needed.</p>
                                   <table>
                                       <thead><tr><th>3-Itemset</th><th>Transactions</th><th>Count (σ)</th><th>Support (s)</th><th>Meet Threshold? (≥ 40%)</th></tr></thead>
                                       <tbody>
                                           <tr><td>{Eggs, Milk, Yogurt}</td><td>2, 4</td><td>2</td><td>2/5 = 40%</td><td class="check-mark">Yes</td></tr>
                                       </tbody>
                                   </table>
                                   <p><strong>L3 (Frequent 3-Itemsets):</strong> {Eggs, Milk, Yogurt}</p>
                                   <p>(Cannot generate C4 from L3 as there's only one itemset). Stop finding frequent itemsets.</p>

                                   <h4>Step 5: Generate Association Rules (Support ≥ 40% and Confidence ≥ 60%)</h4>

                                   <h5>For 2-Itemset {Bread, Milk}:</h5>
                                   <table>
                                        <thead><tr><th>Rule</th><th>Support</th><th>Confidence Calculation</th><th>Confidence</th><th>Meet Threshold? (≥ 60%)</th></tr></thead>
                                        <tbody>
                                            <tr><td>Bread → Milk</td><td>40%</td><td><code>σ(Bread, Milk) / σ(Bread) = 2/2</code></td><td>100%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Milk → Bread</td><td>40%</td><td><code>σ(Bread, Milk) / σ(Milk) = 2/5</code></td><td>40%</td><td class="cross-mark">No</td></tr>
                                        </tbody>
                                   </table>

                                   <h5>For 2-Itemset {Cheese, Milk}:</h5>
                                   <table>
                                        <thead><tr><th>Rule</th><th>Support</th><th>Confidence Calculation</th><th>Confidence</th><th>Meet Threshold? (≥ 60%)</th></tr></thead>
                                        <tbody>
                                            <tr><td>Cheese → Milk</td><td>40%</td><td><code>σ(Cheese, Milk) / σ(Cheese) = 2/2</code></td><td>100%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Milk → Cheese</td><td>40%</td><td><code>σ(Cheese, Milk) / σ(Milk) = 2/5</code></td><td>40%</td><td class="cross-mark">No</td></tr>
                                        </tbody>
                                   </table>

                                   <h5>For 2-Itemset {Eggs, Milk}:</h5>
                                   <table>
                                        <thead><tr><th>Rule</th><th>Support</th><th>Confidence Calculation</th><th>Confidence</th><th>Meet Threshold? (≥ 60%)</th></tr></thead>
                                        <tbody>
                                            <tr><td>Eggs → Milk</td><td>60%</td><td><code>σ(Eggs, Milk) / σ(Eggs) = 3/3</code></td><td>100%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Milk → Eggs</td><td>60%</td><td><code>σ(Eggs, Milk) / σ(Milk) = 3/5</code></td><td>60%</td><td class="check-mark">Yes</td></tr>
                                        </tbody>
                                   </table>

                                   <h5>For 2-Itemset {Eggs, Yogurt}:</h5>
                                   <table>
                                        <thead><tr><th>Rule</th><th>Support</th><th>Confidence Calculation</th><th>Confidence</th><th>Meet Threshold? (≥ 60%)</th></tr></thead>
                                        <tbody>
                                            <tr><td>Eggs → Yogurt</td><td>40%</td><td><code>σ(Eggs, Yogurt) / σ(Eggs) = 2/3</code></td><td>67%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Yogurt → Eggs</td><td>40%</td><td><code>σ(Eggs, Yogurt) / σ(Yogurt) = 2/3</code></td><td>67%</td><td class="check-mark">Yes</td></tr>
                                        </tbody>
                                   </table>

                                   <h5>For 2-Itemset {Milk, Yogurt}:</h5>
                                   <table>
                                        <thead><tr><th>Rule</th><th>Support</th><th>Confidence Calculation</th><th>Confidence</th><th>Meet Threshold? (≥ 60%)</th></tr></thead>
                                        <tbody>
                                            <tr><td>Milk → Yogurt</td><td>60%</td><td><code>σ(Milk, Yogurt) / σ(Milk) = 3/5</code></td><td>60%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Yogurt → Milk</td><td>60%</td><td><code>σ(Milk, Yogurt) / σ(Yogurt) = 3/3</code></td><td>100%</td><td class="check-mark">Yes</td></tr>
                                        </tbody>
                                   </table>

                                   <h5>For 3-Itemset {Eggs, Milk, Yogurt}:</h5>
                                   <table>
                                       <thead><tr><th>Rule</th><th>Support</th><th>Confidence Calculation</th><th>Confidence</th><th>Meet Threshold? (≥ 60%)</th></tr></thead>
                                        <tbody>
                                            <tr><td>{Eggs, Milk} → Yogurt</td><td>40%</td><td><code>σ(Eggs, Milk, Yogurt) / σ(Eggs, Milk) = 2/3</code></td><td>67%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>{Eggs, Yogurt} → Milk</td><td>40%</td><td><code>σ(Eggs, Milk, Yogurt) / σ(Eggs, Yogurt) = 2/2</code></td><td>100%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>{Milk, Yogurt} → Eggs</td><td>40%</td><td><code>σ(Eggs, Milk, Yogurt) / σ(Milk, Yogurt) = 2/3</code></td><td>67%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Eggs → {Milk, Yogurt}</td><td>40%</td><td><code>σ(Eggs, Milk, Yogurt) / σ(Eggs) = 2/3</code></td><td>67%</td><td class="check-mark">Yes</td></tr>
                                            <tr><td>Milk → {Eggs, Yogurt}</td><td>40%</td><td><code>σ(Eggs, Milk, Yogurt) / σ(Milk) = 2/5</code></td><td>40%</td><td class="cross-mark">No</td></tr>
                                            <tr><td>Yogurt → {Eggs, Milk}</td><td>40%</td><td><code>σ(Eggs, Milk, Yogurt) / σ(Yogurt) = 2/3</code></td><td>67%</td><td class="check-mark">Yes</td></tr>
                                        </tbody>
                                   </table>


                                   <h4>Step 6: Final Strong Association Rules</h4>
                                    <p>(Rules meeting Support ≥ 40% AND Confidence ≥ 60%)</p>
                                    <table>
                                        <thead><tr><th>Rule</th><th>Support</th><th>Confidence</th><th>Interpretation</th></tr></thead>
                                        <tbody>
                                            <tr><td>Bread → Milk</td><td>40%</td><td>100%</td><td>When customers buy Bread, they always buy Milk</td></tr>
                                            <tr><td>Cheese → Milk</td><td>40%</td><td>100%</td><td>When customers buy Cheese, they always buy Milk</td></tr>
                                            <tr><td>Eggs → Milk</td><td>60%</td><td>100%</td><td>When customers buy Eggs, they always buy Milk</td></tr>
                                            <tr><td>Milk → Eggs</td><td>60%</td><td>60%</td><td>When customers buy Milk, they buy Eggs 60% of the time</td></tr>
                                            <tr><td>Eggs → Yogurt</td><td>40%</td><td>67%</td><td>When customers buy Eggs, they buy Yogurt 67% of the time</td></tr>
                                            <tr><td>Yogurt → Eggs</td><td>40%</td><td>67%</td><td>When customers buy Yogurt, they buy Eggs 67% of the time</td></tr>
                                            <tr><td>Milk → Yogurt</td><td>60%</td><td>60%</td><td>When customers buy Milk, they buy Yogurt 60% of the time</td></tr>
                                            <tr><td>Yogurt → Milk</td><td>60%</td><td>100%</td><td>When customers buy Yogurt, they always buy Milk</td></tr>
                                            <tr><td>{Eggs, Milk} → Yogurt</td><td>40%</td><td>67%</td><td>When customers buy Eggs and Milk, they buy Yogurt 67% of the time</td></tr>
                                            <tr><td>{Eggs, Yogurt} → Milk</td><td>40%</td><td>100%</td><td>When customers buy Eggs and Yogurt, they always buy Milk</td></tr>
                                            <tr><td>{Milk, Yogurt} → Eggs</td><td>40%</td><td>67%</td><td>When customers buy Milk and Yogurt, they buy Eggs 67% of the time</td></tr>
                                            <tr><td>Eggs → {Milk, Yogurt}</td><td>40%</td><td>67%</td><td>When customers buy Eggs, they buy both Milk and Yogurt 67% of the time</td></tr>
                                            <tr><td>Yogurt → {Eggs, Milk}</td><td>40%</td><td>67%</td><td>When customers buy Yogurt, they buy both Eggs and Milk 67% of the time</td></tr>
                                        </tbody>
                                    </table>

                                   <h4>Explanation of Calculations</h4>
                                    <ul>
                                        <li><strong>Support(X)</strong> = Number of transactions containing X / Total number of transactions</li>
                                        <li><strong>Support(X∪Y)</strong> = Support(XUY) = Number of transactions containing both X and Y / Total transactions</li>
                                        <li><strong>Confidence(X→Y)</strong> = Support(X∪Y) / Support(X) = Probability of finding Y when X is present</li>
                                    </ul>
                               </div>
                           </div>
                       </div> <!-- End Detailed Apriori Example Accordion -->
                       <!-- **** END OF DETAILED APRIORI EXAMPLE **** -->

                     </div>
                 </div>
                 <div class="accordion-item">
                      <button class="accordion-header">FP-Growth Algorithm</button>
                      <div class="accordion-panel">
                          <p>Mines frequent itemsets without candidate generation using an FP-Tree.</p>
                          <h4>Steps Overview:</h4><ol><li>Scan DB, find frequent items, sort descending by support.</li><li>Scan DB again, build FP-Tree using ordered frequent items per transaction.</li><li>Recursively mine FP-Tree using conditional pattern bases and conditional FP-Trees.</li></ol>
                           <h4>Advantages:</h4><p>Faster than Apriori (fewer scans, no candidates).</p>
                           <h4>Disadvantages:</h4><p>FP-Tree can be complex/memory-intensive.</p>
                            <div class="accordion"><div class="accordion-item"><button class="accordion-header">Example: FP-Growth Concepts (Example 1, minsup count=3)</button><div class="accordion-panel">
                                 <p>Using the same 5-transaction table as Apriori example (minsup count=3).</p>
                                 <p><strong>Frequent items sorted: B(5), T(4), M(3).</strong></p>
                                 <p><strong>Ordered Transactions: {B,T,M}, {B,M}, {B,T}, {B,T,M}, {B,T}</strong></p>
                                 <p><strong>Build FP-Tree (Final):</strong> Null -> B:5 -> (T:4 -> M:2) & (M:1)</p>
                                 <p><strong>Mine Tree:</strong></p>
                                 <ul><li>Mine 'M': Cond. Base={{B,T:2},{B:1}}. Cond. Tree=Null->B:3. Pattern={B,M}:3</li><li>Mine 'T': Cond. Base={{B:4}}. Cond. Tree=Null->B:4. Pattern={B,T}:4</li><li>Mine 'B': Cond. Base={}. Pattern={B}:5</li></ul>
                                 <p><strong>Frequent Itemsets: {B}, {T}, {M}, {B,T}, {B,M}</strong> (Count ≥ 3)</p>
                            </div></div></div>
                      </div>
                 </div>
             </div> <!-- End Main Accordion for Formulas -->
        </section>

        <!-- Quiz Sections -->
        <div id="fill" class="main-content">
            <h2>Fill in the Blank Questions</h2>
            <div id="fill-questions"></div>
        </div>
        <div id="tf" class="main-content">
            <h2>True/False Questions</h2>
            <div id="tf-questions"></div>
        </div>
        <div id="mc" class="main-content">
            <h2>Multiple Choice Questions</h2>
            <div id="mc-questions"></div>
        </div>

    </div> <!-- End Container -->

    <script>
        // --- START OF QUIZ DATA (Data Mining Only) ---
        const fillInTheBlank = [
            { question: "_______ is the process of discovering hidden patterns, correlations, and knowledge from large amounts of data.", options: ["Data Analysis", "Data Warehousing", "Data Mining", "Database Querying"], answer: "Data Mining" },
            { question: "Finding web pages containing specific keywords is generally NOT considered data mining, but rather _______.", options: ["Information Retrieval", "Pattern Recognition", "Clustering", "Classification"], answer: "Information Retrieval" },
            { question: "The challenge of handling datasets with hundreds or thousands of attributes is known as _______.", options: ["Scalability", "Heterogeneity", "High Dimensionality", "Complexity"], answer: "High Dimensionality" },
            { question: "Handling data containing text, images, and audio requires techniques for _______ data.", options: ["Structured", "Numerical", "Complex", "Low-dimensional"], answer: "Complex" },
            { question: "Handling missing values, noise, and inconsistencies is part of the _______ step in data mining.", options: ["Data Integration", "Data Selection", "Data Cleaning", "Pattern Evaluation"], answer: "Data Cleaning" },
            { question: "Combining data from multiple sources into a single repository is known as _______.", options: ["Data Cleaning", "Data Transformation", "Data Selection", "Data Integration"], answer: "Data Integration" },
            { question: "Predictive data mining models include classification and _______.", options: ["Clustering", "Association", "Regression", "Summarization"], answer: "Regression" },
            { question: "Descriptive data mining models include clustering and _______.", options: ["Classification", "Regression", "Forecasting", "Association"], answer: "Association" },
            { question: "Grouping similar customers based on purchasing behavior is an example of _______.", options: ["Regression", "Classification", "Clustering", "Association"], answer: "Clustering" },
            { question: "Discovering rules like {Diapers} → {Milk} is the goal of _______ analysis.", options: ["Regression", "Classification", "Clustering", "Association"], answer: "Association" },
            { question: "A group of items that appear together, like {Milk, Bread}, is an _______.", options: ["Association", "Itemset", "Cluster", "Pattern"], answer: "Itemset" },
            { question: "The frequency of occurrence of an itemset is its _______ count.", options: ["Confidence", "Support", "Lift", "Interest"], answer: "Support" },
            { question: "An itemset whose support is above a minimum threshold is called a _______ itemset.", options: ["Candidate", "Maximal", "Closed", "Frequent"], answer: "Frequent" },
            { question: "A frequent itemset with no superset having the same support is a _______ frequent itemset.", options: ["Maximal", "Candidate", "Closed", "Basic"], answer: "Closed" },
            { question: "A frequent itemset with no frequent superset is a _______ frequent itemset.", options: ["Maximal", "Candidate", "Closed", "Basic"], answer: "Maximal" },
            { question: "The measure σ(X∪Y)/σ(X) calculates the _______ of the rule X→Y.", options: ["Support", "Lift", "Confidence", "Interest"], answer: "Confidence" },
            { question: "The _______ principle states that if an itemset is frequent, all its subsets must be frequent.", options: ["FP-Growth", "Clustering", "Apriori", "Regression"], answer: "Apriori" },
            { question: "The _______ algorithm avoids candidate generation by using a compact tree structure.", options: ["Apriori", "K-Means", "FP-Growth", "Decision Tree"], answer: "FP-Growth" },
            { question: "In Python, the _______ command is used to install libraries like pandas or mlxtend.", options: ["python install", "import", "pip install", "lib install"], answer: "pip install" },
            { question: "The final step in data mining where patterns are presented to the user is called _______.", options: ["Data Selection", "Pattern Evaluation", "Data Mining", "Knowledge Presentation"], answer: "Knowledge Presentation" }
        ];
        const trueOrFalse = [
            { question: "Data mining only deals with structured data from databases.", answer: false },
            { question: "Scalability is not a major challenge for data mining algorithms.", answer: false },
            { question: "Traditional statistical analysis based on hypothesis testing is always sufficient for modern large datasets.", answer: false },
            { question: "Data transformation involves retrieving relevant data from a database.", answer: false }, // That's Data Selection
            { question: "Classification is a type of descriptive data mining model.", answer: false }, // It's Predictive
            { question: "Regression predicts discrete class labels.", answer: false }, // Predicts continuous values
            { question: "Clustering requires labeled data to form groups.", answer: false }, // It's Unsupervised
            { question: "Support count and support percentage are the same thing.", answer: false },
            { question: "All frequent itemsets are also closed itemsets.", answer: false },
            { question: "A maximal frequent itemset is always a closed frequent itemset.", answer: true }, // By definition, maximal implies no *frequent* superset. If a superset had the same support, it would also be frequent, making it non-maximal. So a maximal itemset cannot have a same-support superset.
            { question: "Confidence measures how frequently items X and Y appear together in transactions.", answer: false }, // That's Support(X U Y)
            { question: "The Apriori algorithm scans the database only once.", answer: false },
            { question: "FP-Growth generates candidate itemsets similar to Apriori.", answer: false },
            { question: "The FP-Tree stores all original transaction data.", answer: false }, // Stores compressed frequent item info
            { question: "Python's IDLE cannot be used to save script files.", answer: false }
        ];
        const multipleChoice = [
            { question: "Which is NOT typically considered a primary challenge motivating data mining?", options: ["Scalability", "High Dimensionality", "Simple Data Types", "Heterogeneous Data"], answer: "Simple Data Types" },
            { question: "Which data mining step involves handling errors, outliers, and missing values?", options: ["Data Integration", "Data Cleaning", "Data Selection", "Pattern Evaluation"], answer: "Data Cleaning" },
            { question: "Predicting house prices based on features like size and location is an example of:", options: ["Classification", "Clustering", "Association", "Regression"], answer: "Regression" },
            { question: "Grouping genes with similar functionality based on expression data is an example of:", options: ["Classification", "Clustering", "Association", "Regression"], answer: "Clustering" },
            { question: "What does the support of an itemset {A, B} represent?", options: ["How often A occurs", "How often B occurs", "The probability of B occurring given A", "The fraction of transactions containing both A and B"], answer: "The fraction of transactions containing both A and B" },
            { question: "If minsup = 50% and an itemset appears in 2 out of 5 transactions, is it frequent?", options: ["Yes", "No", "Cannot be determined"], answer: "No" }, // 2/5 = 40% < 50%
            { question: "If Support({A,B,C}) = 30% and Support({A,B}) = 60%, what is the Confidence({A,B} → {C})?", options: ["30%", "60%", "50%", "20%"], answer: "50%" }, // 30% / 60% = 0.5
            { question: "Which algorithm relies heavily on the principle 'all subsets of a frequent itemset must be frequent'?", options: ["FP-Growth", "K-Means", "Apriori", "DBSCAN"], answer: "Apriori" },
            { question: "What is a primary advantage of FP-Growth over Apriori?", options: ["Easier to implement", "Requires less memory", "Avoids candidate generation", "Works better with sparse data"], answer: "Avoids candidate generation" },
            { question: "What Python library provides implementations of Apriori and FP-Growth?", options: ["Numpy", "Pandas", "Scikit-learn", "Mlxtend"], answer: "Mlxtend" },
            { question: "Which data mining task corresponds to 'finding groups of objects such that objects in a group are similar'?", options: ["Classification", "Regression", "Clustering", "Association Rule Mining"], answer: "Clustering" },
            { question: "Which Python environment provides a simple text editor and interactive shell?", options: ["CMD/Terminal", "Jupyter Notebook", "VS Code", "IDLE"], answer: "IDLE" },
            { question: "Which task type does Association Rule Mining fall under?", options: ["Predictive", "Descriptive", "Reinforcement", "Regression"], answer: "Descriptive" },
             { question: "What is the term for an itemset that is frequent, but has no frequent supersets?", options: ["Closed Itemset", "Candidate Itemset", "Maximal Itemset", "k-Itemset"], answer: "Maximal Itemset" },
            { question: "What is the first step in the Apriori algorithm?", options: ["Generate Candidate 2-itemsets", "Prune infrequent subsets", "Scan database to count 1-itemsets", "Build FP-Tree"], answer: "Scan database to count 1-itemsets" }
        ];
        // --- END OF QUIZ DATA ---


        // --- START OF SCRIPT LOGIC ---
        document.addEventListener('DOMContentLoaded', () => {
            const mainTabButtons = document.querySelectorAll('.main-tabs .tab-button');
            const mainTabContents = document.querySelectorAll('.main-content');
            const fillContainer = document.getElementById('fill-questions');
            const tfContainer = document.getElementById('tf-questions');
            const mcContainer = document.getElementById('mc-questions');
            const accordionHeaders = document.querySelectorAll('.accordion-header');

            // --- Main Tab Switching Logic ---
            mainTabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');
                    mainTabButtons.forEach(btn => btn.classList.remove('active'));
                    mainTabContents.forEach(content => content.classList.remove('active'));
                    button.classList.add('active');
                    const targetContent = document.getElementById(tabId);
                    if (targetContent) { targetContent.classList.add('active'); }
                });
            });

            // --- Accordion Logic (for Glossary AND Examples) ---
             accordionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    // Toggle active class on the header
                    this.classList.toggle('active');
                    const panel = this.nextElementSibling;

                    // Toggle the 'open' class which controls padding and max-height via CSS
                    panel.classList.toggle('open');

                    // Optional: Close other sibling accordions when one is opened (uncomment if desired)
                    // const parentAccordion = this.closest('.accordion');
                    // if (parentAccordion) {
                    //    const allHeaders = parentAccordion.querySelectorAll(':scope > .accordion-item > .accordion-header');
                    //    allHeaders.forEach(otherHeader => {
                    //         if (otherHeader !== this && otherHeader.classList.contains('active')) {
                    //             otherHeader.classList.remove('active');
                    //             otherHeader.nextElementSibling.classList.remove('open');
                    //         }
                    //     });
                    // }
                });
            });

             // --- QUIZ LOGIC (Functions: handleOptionSelection, showFeedback, loadFillInTheBlankQuestions, loadTrueFalseQuestions, loadMultipleChoiceQuestions) ---
            function handleOptionSelection(button, questionDiv) {
                const siblings = questionDiv.querySelectorAll('.option-button.selected');
                siblings.forEach(sib => sib.classList.remove('selected'));
                button.classList.add('selected');
                const existingFeedback = questionDiv.querySelector('.feedback');
                if (existingFeedback) { existingFeedback.remove(); }
            }
            function showFeedback(questionDiv, isCorrect, correctAnswer) {
                const existingFeedback = questionDiv.querySelector('.feedback');
                if (existingFeedback) { existingFeedback.remove(); }
                const feedback = document.createElement('div'); feedback.className = 'feedback';
                if (isCorrect) { feedback.classList.add('correct'); feedback.textContent = 'Correct!'; }
                else { feedback.classList.add('incorrect'); feedback.textContent = `Incorrect. Correct answer: ${correctAnswer}`; }
                const checkButton = questionDiv.querySelector('.check-answer');
                if (checkButton) { checkButton.parentNode.insertBefore(feedback, checkButton.nextSibling); }
                else { questionDiv.appendChild(feedback); }
            }
            function loadFillInTheBlankQuestions() {
                fillContainer.innerHTML = '';
                fillInTheBlank.forEach((q) => {
                    const questionDiv = document.createElement('div'); questionDiv.className = 'question';
                    const questionText = document.createElement('p'); questionText.textContent = q.question; questionDiv.appendChild(questionText);
                    const optionsDiv = document.createElement('div'); optionsDiv.className = 'options';
                    q.options.forEach(option => { const optionButton = document.createElement('button'); optionButton.className = 'option-button'; optionButton.textContent = option; optionButton.addEventListener('click', () => handleOptionSelection(optionButton, questionDiv)); optionsDiv.appendChild(optionButton); });
                    questionDiv.appendChild(optionsDiv);
                    const checkButton = document.createElement('button'); checkButton.className = 'check-answer'; checkButton.textContent = 'Check Answer'; checkButton.addEventListener('click', () => { const selected = questionDiv.querySelector('.option-button.selected'); showFeedback(questionDiv, selected && selected.textContent === q.answer, q.answer); });
                    questionDiv.appendChild(checkButton); fillContainer.appendChild(questionDiv);
                });
            }
            function loadTrueFalseQuestions() {
                 tfContainer.innerHTML = '';
                trueOrFalse.forEach((q) => {
                    const questionDiv = document.createElement('div'); questionDiv.className = 'question';
                    const questionText = document.createElement('p'); questionText.textContent = q.question; questionDiv.appendChild(questionText);
                    const optionsDiv = document.createElement('div'); optionsDiv.className = 'options';
                    const trueButton = document.createElement('button'); trueButton.className = 'option-button'; trueButton.textContent = 'True'; trueButton.addEventListener('click', () => handleOptionSelection(trueButton, questionDiv)); optionsDiv.appendChild(trueButton);
                    const falseButton = document.createElement('button'); falseButton.className = 'option-button'; falseButton.textContent = 'False'; falseButton.addEventListener('click', () => handleOptionSelection(falseButton, questionDiv)); optionsDiv.appendChild(falseButton);
                    questionDiv.appendChild(optionsDiv);
                    const checkButton = document.createElement('button'); checkButton.className = 'check-answer'; checkButton.textContent = 'Check Answer';
                    checkButton.addEventListener('click', () => {
                        const selected = questionDiv.querySelector('.option-button.selected'); const correctAnswerText = q.answer ? 'True' : 'False'; const isCorrect = selected && ((selected.textContent === 'True' && q.answer) || (selected.textContent === 'False' && !q.answer)); showFeedback(questionDiv, isCorrect, correctAnswerText);
                    });
                    questionDiv.appendChild(checkButton); tfContainer.appendChild(questionDiv);
                });
            }
            function loadMultipleChoiceQuestions() {
                 mcContainer.innerHTML = '';
                multipleChoice.forEach((q) => {
                    const questionDiv = document.createElement('div'); questionDiv.className = 'question';
                    const questionText = document.createElement('p'); questionText.textContent = q.question; questionDiv.appendChild(questionText);
                    const optionsDiv = document.createElement('div'); optionsDiv.className = 'options';
                     q.options.forEach(option => { const optionButton = document.createElement('button'); optionButton.className = 'option-button'; optionButton.textContent = option; optionButton.addEventListener('click', () => handleOptionSelection(optionButton, questionDiv)); optionsDiv.appendChild(optionButton); });
                    questionDiv.appendChild(optionsDiv);
                    const checkButton = document.createElement('button'); checkButton.className = 'check-answer'; checkButton.textContent = 'Check Answer'; checkButton.addEventListener('click', () => { const selected = questionDiv.querySelector('.option-button.selected'); showFeedback(questionDiv, selected && selected.textContent === q.answer, q.answer); });
                    questionDiv.appendChild(checkButton); mcContainer.appendChild(questionDiv);
                });
            }

            // --- Initial Load ---
            loadFillInTheBlankQuestions();
            loadTrueFalseQuestions();
            loadMultipleChoiceQuestions();

            // --- Activate first tab ---
             if (mainTabButtons.length > 0) {
                mainTabButtons[0].classList.add('active');
                const firstTabId = mainTabButtons[0].getAttribute('data-tab');
                 const firstTabContent = document.getElementById(firstTabId);
                if(firstTabContent) firstTabContent.classList.add('active');
            }

        }); // End DOMContentLoaded
        // --- END OF SCRIPT LOGIC ---
    </script>
</body>
</html>
